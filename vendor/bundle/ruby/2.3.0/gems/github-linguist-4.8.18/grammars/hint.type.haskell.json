{
  "fileTypes": [

  ],
  "scopeName": "hint.type.haskell",
  "macros": {
    "identStartCharClass": "[\\p{Ll}_\\p{Lu}\\p{Lt}]",
    "identContCharClass": "[\\p{Ll}_\\p{Lu}\\p{Lt}']",
    "identCharClass": "[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']",
    "functionNameOne": "[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*",
    "classNameOne": "[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*",
    "functionName": "(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*",
    "className": "[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*",
    "operatorChar": "[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]",
    "operator": "[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+",
    "operatorFun": "(?:\\((?!--+\\))[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+\\))",
    "basicChar": "[\\ -\\[\\]-~]",
    "escapeChar": "\\\\(?:NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\\\\\"'\\&])",
    "octalChar": "(?:\\\\o[0-7]+)",
    "hexChar": "(?:\\\\x[0-9A-Fa-f]+)",
    "controlChar": "(?:\\^[A-Z@\\[\\]\\\\\\^_])",
    "character": "(?:[\\ -\\[\\]-~]|\\\\(?:NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\\\\\"'\\&])|(?:\\\\o[0-7]+)|(?:\\\\x[0-9A-Fa-f]+)|(?:\\^[A-Z@\\[\\]\\\\\\^_])|[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])",
    "functionTypeDeclaration": "(?:(?:((?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*|(?:\\((?!--+\\))[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+\\)))(?:(?:\\s*,\\s*)(?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*|(?:\\((?!--+\\))[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+\\))))*))(?:\\s*((?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])(?:::|∷)(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]))))",
    "doubleColonOperator": "(?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])(?:::|∷)(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])",
    "ctorTypeDeclaration": "(?:(?:((?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*|(?:\\((?!--+\\))[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+\\)))(?:(?:\\s*,\\s*)(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*|(?:\\((?!--+\\))[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+\\))))*))(?:\\s*((?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])(?:::|∷)(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]))))",
    "ctorArgs": "(?!deriving)(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*|(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*|(?:(?!deriving)(?:[\\w()'→⇒\\[\\],]|->|=>)+\\s*)+)",
    "ctor": "(?:(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*)\\s*)(?:((?:(?!deriving)(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*|(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*|(?:(?!deriving)(?:[\\w()'→⇒\\[\\],]|->|=>)+\\s*)+))(?:(?:\\s+)(?:(?!deriving)(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*|(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*|(?:(?!deriving)(?:[\\w()'→⇒\\[\\],]|->|=>)+\\s*)+)))*)?))",
    "typeDeclOne": "(?:(?!(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))where(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])))(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*|(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*))",
    "typeDecl": "(?>(?:(?:(?!(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))where(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])))(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*|(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)))(?:\\s+(?:(?!(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))where(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])))(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*|(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)))*)",
    "indentChar": "[ \\t]",
    "indentBlockStart": "^([ \\t]*)",
    "indentBlockEnd": "^(?!\\1[ \\t]|[ \\t]*$)",
    "maybeBirdTrack": "^",
    "lb": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))",
    "rb": "(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))",
    "b": "(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))|(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])))"
  },
  "patterns": [
    {
      "include": "#type_signature"
    }
  ],
  "repository": {
    "block_comment": {
      "patterns": [
        {
          "name": "comment.block.haddock.haskell",
          "begin": "\\{-\\s*[|^]",
          "end": "-\\}",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "0": {
              "name": "punctuation.definition.comment.haddock.haskell"
            }
          },
          "endCaptures": {
            "0": {
              "name": "punctuation.definition.comment.haddock.haskell"
            }
          },
          "patterns": [
            {
              "include": "#block_comment"
            }
          ]
        },
        {
          "name": "comment.block.haskell",
          "begin": "\\{-",
          "end": "-\\}",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "0": {
              "name": "punctuation.definition.comment.block.start.haskell"
            }
          },
          "endCaptures": {
            "0": {
              "name": "punctuation.definition.comment.block.end.haskell"
            }
          },
          "patterns": [
            {
              "include": "#block_comment"
            }
          ]
        }
      ]
    },
    "comments": {
      "patterns": [
        {
          "begin": "(^[ \\t]+)?(?=--+\\s+[|^])",
          "end": "(?!\\G)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.whitespace.comment.leading.haskell"
            }
          },
          "patterns": [
            {
              "name": "comment.line.double-dash.haddock.haskell",
              "begin": "(--+)\\s+([|^])",
              "end": "\\n",
              "beginCaptures": {
                "1": {
                  "name": "punctuation.definition.comment.haskell"
                },
                "2": {
                  "name": "punctuation.definition.comment.haddock.haskell"
                }
              }
            }
          ]
        },
        {
          "begin": "(^[ \\t]+)?(?=--+(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]))",
          "end": "(?!\\G)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.whitespace.comment.leading.haskell"
            }
          },
          "patterns": [
            {
              "name": "comment.line.double-dash.haskell",
              "begin": "--",
              "end": "\\n",
              "beginCaptures": {
                "0": {
                  "name": "punctuation.definition.comment.haskell"
                }
              }
            }
          ]
        },
        {
          "include": "#block_comment"
        }
      ]
    },
    "characters": {
      "patterns": [
        {
          "match": "\\\\(?:NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\\\\\"'\\&])",
          "name": "constant.character.escape.haskell"
        },
        {
          "match": "(?:\\\\o[0-7]+)",
          "name": "constant.character.escape.octal.haskell"
        },
        {
          "match": "(?:\\\\x[0-9A-Fa-f]+)",
          "name": "constant.character.escape.hexadecimal.haskell"
        },
        {
          "match": "(?:\\^[A-Z@\\[\\]\\\\\\^_])",
          "name": "constant.character.escape.control.haskell"
        }
      ]
    },
    "infix_op": {
      "patterns": [
        {
          "name": "entity.name.function.infix.haskell",
          "match": "(?:\\((?!--+\\))[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+\\))"
        }
      ]
    },
    "module_exports": {
      "patterns": [
        {
          "name": "meta.declaration.exports.haskell",
          "begin": "\\(",
          "end": "\\)",
          "patterns": [
            {
              "include": "#comments"
            },
            {
              "include": "#function_name"
            },
            {
              "include": "#type_name"
            },
            {
              "include": "#comma"
            },
            {
              "name": "meta.other.constructor-list.haskell",
              "begin": "(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))\\s*\\(",
              "end": "\\)",
              "patterns": [
                {
                  "include": "#type_ctor"
                },
                {
                  "include": "#attribute_name"
                },
                {
                  "include": "#comma"
                },
                {
                  "match": "\\.\\.",
                  "name": "keyword.operator.wildcard.haskell"
                }
              ]
            },
            {
              "include": "#infix_op"
            }
          ]
        }
      ]
    },
    "module_name": {
      "patterns": [
        {
          "name": "support.other.module.haskell",
          "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))"
        }
      ]
    },
    "module_name_prefix": {
      "patterns": [
        {
          "name": "support.other.module.haskell",
          "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\."
        }
      ]
    },
    "pragma": {
      "patterns": [
        {
          "name": "meta.preprocessor.haskell",
          "begin": "\\{-#",
          "end": "#-\\}",
          "patterns": [
            {
              "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(NOTINLINE CONSTRUCTORLIKE|NOINLINE CONSTRUCTORLIKE|INLINE CONSTRUCTORLIKE|SPECIALISE NOTINLINE|SPECIALIZE NOTINLINE|SPECIALISE NOINLINE|SPECIALIZE NOINLINE|NOTINLINE CONLIKE|SPECIALISE INLINE|SPECIALIZE INLINE|NOINLINE CONLIKE|VECTORISE SCALAR|VECTORIZE SCALAR|OPTIONS_HADDOCK|INLINE CONLIKE|OPTIONS_DERIVE|OPTIONS_CATCH|OPTIONS_NHC98|OPTIONS_HUGS|OVERLAPPABLE|NOVECTORISE|NOVECTORIZE|OPTIONS_GHC|OPTIONS_JHC|OPTIONS_YHC|OVERLAPPING|DEPRECATED|INCOHERENT|INLINEABLE|SPECIALISE|SPECIALIZE|GENERATED|INLINABLE|NOTINLINE|VECTORISE|VECTORIZE|CONTRACT|LANGUAGE|NOINLINE|NOUNPACK|OVERLAPS|INCLUDE|MINIMAL|OPTIONS|WARNING|CFILES|INLINE|SOURCE|UNPACK|CTYPE|RULES|CORE|LINE|ANN|SCC)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))",
              "name": "keyword.other.preprocessor.haskell"
            }
          ]
        }
      ]
    },
    "function_type_declaration": {
      "patterns": [
        {
          "name": "meta.function.type-declaration.haskell",
          "begin": "^([ \\t]*)(?:(?:((?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*|(?:\\((?!--+\\))[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+\\)))(?:(?:\\s*,\\s*)(?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*|(?:\\((?!--+\\))[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+\\))))*))(?:\\s*((?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])(?:::|∷)(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]))))",
          "end": "^(?!\\1[ \\t]|[ \\t]*$)",
          "contentName": "meta.type-signature.haskell",
          "beginCaptures": {
            "2": {
              "patterns": [
                {
                  "include": "#function_name"
                },
                {
                  "include": "#infix_op"
                }
              ]
            },
            "3": {
              "name": "keyword.other.double-colon.haskell"
            }
          },
          "patterns": [
            {
              "include": "#type_signature"
            }
          ]
        }
      ]
    },
    "ctor_type_declaration": {
      "patterns": [
        {
          "name": "meta.ctor.type-declaration.haskell",
          "begin": "^([ \\t]*)(?:(?:((?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*|(?:\\((?!--+\\))[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+\\)))(?:(?:\\s*,\\s*)(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*|(?:\\((?!--+\\))[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+\\))))*))(?:\\s*((?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])(?:::|∷)(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]))))",
          "end": "^(?!\\1[ \\t]|[ \\t]*$)",
          "contentName": "meta.type-signature.haskell",
          "beginCaptures": {
            "2": {
              "patterns": [
                {
                  "include": "#type_ctor"
                },
                {
                  "include": "#infix_op"
                }
              ]
            },
            "3": {
              "name": "keyword.other.double-colon.haskell"
            }
          },
          "patterns": [
            {
              "include": "#type_signature"
            }
          ]
        }
      ]
    },
    "record_field_declaration": {
      "patterns": [
        {
          "name": "meta.record-field.type-declaration.haskell",
          "begin": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(?:(?:((?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*|(?:\\((?!--+\\))[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+\\)))(?:(?:\\s*,\\s*)(?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*|(?:\\((?!--+\\))[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+\\))))*))(?:\\s*((?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])(?:::|∷)(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]))))",
          "end": "(?=(?:(?:((?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*|(?:\\((?!--+\\))[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+\\)))(?:(?:\\s*,\\s*)(?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*|(?:\\((?!--+\\))[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+\\))))*))(?:\\s*((?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])(?:::|∷)(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]))))|})",
          "contentName": "meta.type-signature.haskell",
          "beginCaptures": {
            "1": {
              "patterns": [
                {
                  "include": "#attribute_name"
                },
                {
                  "include": "#infix_op"
                }
              ]
            },
            "2": {
              "name": "keyword.other.double-colon.haskell"
            }
          },
          "patterns": [
            {
              "include": "#type_signature"
            }
          ]
        }
      ]
    },
    "type_signature": {
      "patterns": [
        {
          "include": "#pragma"
        },
        {
          "include": "#comments"
        },
        {
          "name": "keyword.other.forall.haskell",
          "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))forall(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))"
        },
        {
          "include": "#unit"
        },
        {
          "include": "#empty_list"
        },
        {
          "name": "keyword.other.arrow.haskell",
          "match": "(?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])(->|→)(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])"
        },
        {
          "name": "keyword.other.big-arrow.haskell",
          "match": "(?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])(=>|⇒)(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])"
        },
        {
          "include": "#operator"
        },
        {
          "name": "variable.other.generic-type.haskell",
          "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))"
        },
        {
          "include": "#type_name"
        }
      ]
    },
    "unit": {
      "patterns": [
        {
          "name": "constant.language.unit.haskell",
          "match": "\\(\\)"
        }
      ]
    },
    "empty_list": {
      "patterns": [
        {
          "name": "constant.language.empty-list.haskell",
          "match": "\\[\\]"
        }
      ]
    },
    "deriving": {
      "patterns": [
        {
          "include": "#deriving_list"
        },
        {
          "include": "#deriving_simple"
        },
        {
          "include": "#deriving_keyword"
        }
      ]
    },
    "deriving_keyword": {
      "patterns": [
        {
          "name": "meta.deriving.haskell",
          "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(deriving)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))",
          "captures": {
            "1": {
              "name": "keyword.other.haskell"
            }
          }
        }
      ]
    },
    "deriving_list": {
      "patterns": [
        {
          "name": "meta.deriving.haskell",
          "begin": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(deriving)\\s*\\(",
          "end": "\\)",
          "beginCaptures": {
            "1": {
              "name": "keyword.other.haskell"
            }
          },
          "patterns": [
            {
              "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))",
              "captures": {
                "1": {
                  "name": "entity.other.inherited-class.haskell"
                }
              }
            }
          ]
        }
      ]
    },
    "deriving_simple": {
      "patterns": [
        {
          "name": "meta.deriving.haskell",
          "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(deriving)\\s*([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))",
          "captures": {
            "1": {
              "name": "keyword.other.haskell"
            },
            "2": {
              "name": "entity.other.inherited-class.haskell"
            }
          }
        }
      ]
    },
    "infix_function": {
      "patterns": [
        {
          "name": "keyword.operator.function.infix.haskell",
          "match": "(`)(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(`)",
          "captures": {
            "1": {
              "name": "punctuation.definition.entity.haskell"
            },
            "2": {
              "name": "punctuation.definition.entity.haskell"
            }
          }
        }
      ]
    },
    "quasi_quotes": {
      "patterns": [
        {
          "begin": "(\\[)([\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)(\\|)",
          "end": "(\\|)(\\])",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.quasiquotes.begin.haskell"
            },
            "2": {
              "name": "entity.name.tag.haskell"
            }
          },
          "endCaptures": {
            "2": {
              "name": "punctuation.definition.quasiquotes.end.haskell"
            }
          },
          "contentName": "string.quoted.quasiquotes.haskell"
        }
      ]
    },
    "module_decl": {
      "patterns": [
        {
          "name": "meta.declaration.module.haskell",
          "begin": "^([ \\t]*)(module)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))",
          "end": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(where)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))|^(?!\\1[ \\t]|[ \\t]*$)",
          "beginCaptures": {
            "2": {
              "name": "keyword.other.haskell"
            }
          },
          "endCaptures": {
            "1": {
              "name": "keyword.other.haskell"
            }
          },
          "patterns": [
            {
              "include": "#comments"
            },
            {
              "include": "#module_name"
            },
            {
              "include": "#module_exports"
            },
            {
              "include": "#invalid"
            }
          ]
        }
      ]
    },
    "class_decl": {
      "patterns": [
        {
          "name": "meta.declaration.class.haskell",
          "begin": "^([ \\t]*)(class)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))",
          "end": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(where)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))|^(?!\\1[ \\t]|[ \\t]*$)",
          "beginCaptures": {
            "2": {
              "name": "storage.type.class.haskell"
            }
          },
          "endCaptures": {
            "1": {
              "name": "keyword.other.haskell"
            }
          },
          "patterns": [
            {
              "include": "#type_signature"
            }
          ]
        }
      ]
    },
    "instance_decl": {
      "patterns": [
        {
          "name": "meta.declaration.instance.haskell",
          "begin": "^([ \\t]*)(instance)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))",
          "end": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(where)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))|^(?!\\1[ \\t]|[ \\t]*$)",
          "contentName": "meta.type-signature.haskell",
          "beginCaptures": {
            "2": {
              "name": "keyword.other.haskell"
            }
          },
          "endCaptures": {
            "1": {
              "name": "keyword.other.haskell"
            }
          },
          "patterns": [
            {
              "include": "#pragma"
            },
            {
              "include": "#type_signature"
            }
          ]
        }
      ]
    },
    "deriving_instance_decl": {
      "patterns": [
        {
          "name": "meta.declaration.instance.deriving.haskell",
          "begin": "^([ \\t]*)(deriving\\s+instance)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))",
          "end": "^(?!\\1[ \\t]|[ \\t]*$)",
          "contentName": "meta.type-signature.haskell",
          "beginCaptures": {
            "2": {
              "name": "keyword.other.haskell"
            }
          },
          "patterns": [
            {
              "include": "#pragma"
            },
            {
              "include": "#type_signature"
            }
          ]
        }
      ]
    },
    "foreign_import": {
      "patterns": [
        {
          "name": "meta.foreign.haskell",
          "begin": "^([ \\t]*)(foreign)\\s+(import|export)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))",
          "end": "^(?!\\1[ \\t]|[ \\t]*$)",
          "beginCaptures": {
            "2": {
              "name": "keyword.other.haskell"
            },
            "3": {
              "name": "keyword.other.haskell"
            }
          },
          "patterns": [
            {
              "match": "(?:un)?safe",
              "captures": {
                "0": {
                  "name": "keyword.other.haskell"
                }
              }
            },
            {
              "include": "#function_type_declaration"
            },
            {
              "include": "#haskell_expr"
            }
          ]
        }
      ]
    },
    "regular_import": {
      "patterns": [
        {
          "name": "meta.import.haskell",
          "begin": "^([ \\t]*)(import)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))",
          "end": "^(?!\\1[ \\t]|[ \\t]*$)",
          "beginCaptures": {
            "2": {
              "name": "keyword.other.haskell"
            }
          },
          "patterns": [
            {
              "include": "#module_name"
            },
            {
              "include": "#module_exports"
            },
            {
              "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(qualified|as|hiding)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))",
              "captures": {
                "1": {
                  "name": "keyword.other.haskell"
                }
              }
            }
          ]
        }
      ]
    },
    "data_decl": {
      "patterns": [
        {
          "name": "meta.declaration.type.data.haskell",
          "begin": "^([ \\t]*)(data|newtype)\\s+((?:(?!=|where).)*)",
          "end": "^(?!\\1[ \\t]|[ \\t]*$)",
          "beginCaptures": {
            "2": {
              "name": "storage.type.data.haskell"
            },
            "3": {
              "name": "meta.type-signature.haskell",
              "patterns": [
                {
                  "include": "#family_and_instance"
                },
                {
                  "include": "#type_signature"
                }
              ]
            }
          },
          "patterns": [
            {
              "include": "#comments"
            },
            {
              "include": "#where"
            },
            {
              "include": "#deriving"
            },
            {
              "include": "#assignment_op"
            },
            {
              "match": "(?:(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*)\\s*)(?:((?:(?!deriving)(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*|(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*|(?:(?!deriving)(?:[\\w()'→⇒\\[\\],]|->|=>)+\\s*)+))(?:(?:\\s+)(?:(?!deriving)(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*|(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*|(?:(?!deriving)(?:[\\w()'→⇒\\[\\],]|->|=>)+\\s*)+)))*)?))",
              "captures": {
                "1": {
                  "patterns": [
                    {
                      "include": "#type_ctor"
                    }
                  ]
                },
                "2": {
                  "name": "meta.type-signature.haskell",
                  "patterns": [
                    {
                      "include": "#type_signature"
                    }
                  ]
                }
              }
            },
            {
              "match": "\\|",
              "captures": {
                "0": {
                  "name": "punctuation.separator.pipe.haskell"
                }
              }
            },
            {
              "name": "meta.declaration.type.data.record.block.haskell",
              "begin": "\\{",
              "beginCaptures": {
                "0": {
                  "name": "keyword.operator.record.begin.haskell"
                }
              },
              "end": "\\}",
              "endCaptures": {
                "0": {
                  "name": "keyword.operator.record.end.haskell"
                }
              },
              "patterns": [
                {
                  "include": "#comments"
                },
                {
                  "include": "#comma"
                },
                {
                  "include": "#record_field_declaration"
                }
              ]
            },
            {
              "include": "#ctor_type_declaration"
            }
          ]
        }
      ]
    },
    "type_alias": {
      "patterns": [
        {
          "name": "meta.declaration.type.type.haskell",
          "begin": "^([ \\t]*)(type)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))",
          "end": "^(?!\\1[ \\t]|[ \\t]*$)",
          "contentName": "meta.type-signature.haskell",
          "beginCaptures": {
            "2": {
              "name": "storage.type.data.haskell"
            }
          },
          "patterns": [
            {
              "include": "#comments"
            },
            {
              "include": "#family_and_instance"
            },
            {
              "include": "#where"
            },
            {
              "include": "#assignment_op"
            },
            {
              "include": "#type_signature"
            }
          ]
        }
      ]
    },
    "keywords": {
      "patterns": [
        {
          "name": "keyword.other.haskell",
          "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(deriving|where|data|type|newtype)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))"
        },
        {
          "name": "storage.type.haskell",
          "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(data|type|newtype)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))"
        },
        {
          "name": "keyword.operator.haskell",
          "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))infix[lr]?(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))"
        },
        {
          "name": "keyword.control.haskell",
          "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(do|if|then|else|case|of|let|in|default)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))"
        }
      ]
    },
    "c_preprocessor": {
      "patterns": [
        {
          "name": "meta.preprocessor.c.haskell",
          "begin": "^(?=#)",
          "end": "(?<!\\\\)(?=\\n)",
          "patterns": [
            {
              "include": "source.c"
            }
          ]
        }
      ]
    },
    "string": {
      "patterns": [
        {
          "name": "string.quoted.double.haskell",
          "begin": "\"",
          "end": "\"",
          "beginCaptures": {
            "0": {
              "name": "punctuation.definition.string.begin.haskell"
            }
          },
          "endCaptures": {
            "0": {
              "name": "punctuation.definition.string.end.haskell"
            }
          },
          "patterns": [
            {
              "include": "#characters"
            },
            {
              "begin": "\\\\\\s",
              "end": "\\\\",
              "beginCaptures": {
                "0": {
                  "name": "markup.other.escape.newline.begin.haskell"
                }
              },
              "endCaptures": {
                "0": {
                  "name": "markup.other.escape.newline.end.haskell"
                }
              },
              "patterns": [
                {
                  "include": "#invalid"
                }
              ]
            }
          ]
        }
      ]
    },
    "newline_escape": {
      "patterns": [
        {
          "name": "markup.other.escape.newline.haskell",
          "match": "\\\\$"
        }
      ]
    },
    "quoted_character": {
      "patterns": [
        {
          "name": "string.quoted.single.haskell",
          "match": "(')((?:[\\ -\\[\\]-~]|\\\\(?:NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\\\\\"'\\&])|(?:\\\\o[0-7]+)|(?:\\\\x[0-9A-Fa-f]+)|(?:\\^[A-Z@\\[\\]\\\\\\^_])|[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]))(')",
          "captures": {
            "1": {
              "name": "punctuation.definition.string.begin.haskell"
            },
            "2": {
              "patterns": [
                {
                  "include": "#characters"
                }
              ]
            },
            "3": {
              "name": "punctuation.definition.string.end.haskell"
            }
          }
        }
      ]
    },
    "scoped_type": {
      "patterns": [
        {
          "match": "\\(((?<paren>(?:[^\\(\\)]|\\(\\g<paren>\\))*)(?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])(?:::|∷)(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])(?<paren2>(?:[^\\(\\)]|\\(\\g<paren2>\\))*))\\)",
          "captures": {
            "1": {
              "patterns": [
                {
                  "include": "#haskell_expr"
                }
              ]
            }
          }
        },
        {
          "match": "((?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])(?:::|∷)(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]))(.*?)(?=(?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])(<-|=)(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])|$)",
          "captures": {
            "1": {
              "name": "keyword.other.double-colon.haskell"
            },
            "2": {
              "name": "meta.type-signature.haskell",
              "patterns": [
                {
                  "include": "#type_signature"
                }
              ]
            }
          }
        }
      ]
    },
    "scoped_type_override": {
      "patterns": [
        {
          "match": "^([ \\t]*)(?:(?:((?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*|(?:\\((?!--+\\))[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+\\)))(?:(?:\\s*,\\s*)(?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*|(?:\\((?!--+\\))[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+\\))))*))(?:\\s*((?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])(?:::|∷)(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]))))(.*)(?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])(<-|=)(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])",
          "captures": {
            "2": {
              "patterns": [
                {
                  "include": "#identifier"
                }
              ]
            },
            "3": {
              "name": "keyword.other.double-colon.haskell"
            },
            "4": {
              "name": "meta.type-signature.haskell",
              "patterns": [
                {
                  "include": "#type_signature"
                }
              ]
            },
            "5": {
              "patterns": [
                {
                  "include": "#assignment_op"
                },
                {
                  "include": "#operator"
                }
              ]
            }
          }
        }
      ]
    },
    "comma": {
      "patterns": [
        {
          "name": "punctuation.separator.comma.haskell",
          "match": ","
        }
      ]
    },
    "lit_num": {
      "patterns": [
        {
          "name": "constant.numeric.hexadecimal.haskell",
          "match": "0[xX][0-9a-fA-F]+"
        },
        {
          "name": "constant.numeric.octal.haskell",
          "match": "0[oO][0-7]+"
        },
        {
          "name": "constant.numeric.float.haskell",
          "match": "[0-9]+(\\.[0-9]+[eE][+-]?|\\.|[eE][+-]?)[0-9]+"
        },
        {
          "name": "constant.numeric.decimal.haskell",
          "match": "[0-9]+"
        }
      ]
    },
    "operator": {
      "patterns": [
        {
          "name": "keyword.operator.haskell",
          "match": "[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+"
        }
      ]
    },
    "identifier": {
      "patterns": [
        {
          "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))",
          "name": "identifier.haskell",
          "captures": {
            "0": {
              "patterns": [
                {
                  "include": "#module_name_prefix"
                },
                {
                  "name": "support.function.prelude.haskell",
                  "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(abs|acos|acosh|all|and|any|appendFile|asTypeOf|asin|asinh|atan|atan2|atanh|break|ceiling|compare|concat|concatMap|const|cos|cosh|curry|cycle|decodeFloat|div|divMod|drop|dropWhile|either|elem|encodeFloat|enumFrom|enumFromThen|enumFromThenTo|enumFromTo|error|even|exp|exponent|fail|filter|flip|floatDigits|floatRadix|floatRange|floor|fmap|foldMap|foldl|foldl1|foldr|foldr1|fromEnum|fromInteger|fromIntegral|fromRational|fst|gcd|getChar|getContents|getLine|head|id|init|interact|ioError|isDenormalized|isIEEE|isInfinite|isNaN|isNegativeZero|iterate|last|lcm|length|lex|lines|log|logBase|lookup|map|mapM|mapM_|mappend|max|maxBound|maximum|maybe|mconcat|mempty|min|minBound|minimum|mod|negate|not|notElem|null|odd|or|otherwise|pi|pred|print|product|properFraction|pure|putChar|putStr|putStrLn|quot|quotRem|read|readFile|readIO|readList|readLn|readParen|reads|readsPrec|realToFrac|recip|rem|repeat|replicate|return|reverse|round|scaleFloat|scanl|scanl1|scanr|scanr1|seq|sequence|sequenceA|sequence_|show|showChar|showList|showParen|showString|shows|showsPrec|significand|signum|sin|sinh|snd|span|splitAt|sqrt|subtract|succ|sum|tail|take|takeWhile|tan|tanh|toEnum|toInteger|toRational|traverse|truncate|uncurry|undefined|unlines|until|unwords|unzip|unzip3|userError|words|writeFile|zip|zip3|zipWith|zipWith3)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))"
                }
              ]
            }
          }
        }
      ]
    },
    "type_name": {
      "patterns": [
        {
          "name": "entity.name.type.haskell",
          "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))",
          "captures": {
            "0": {
              "patterns": [
                {
                  "include": "#module_name_prefix"
                },
                {
                  "name": "entity.other.inherited-class.prelude.haskell",
                  "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(Applicative|Bounded|Enum|Eq|Floating|Foldable|Fractional|Functor|Integral|Monad|Monoid|Num|Ord|Read|Real|RealFloat|RealFrac|Show|Traversable)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))"
                },
                {
                  "name": "support.class.prelude.haskell",
                  "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(Either|FilePath|IO|IOError|Integer|Maybe|Ordering|Rational|ReadS|ShowS|String|Bool|Char|Double|Float|Int|Word)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))"
                }
              ]
            }
          }
        }
      ]
    },
    "type_ctor": {
      "patterns": [
        {
          "name": "entity.name.tag.haskell",
          "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))",
          "captures": {
            "0": {
              "patterns": [
                {
                  "include": "#module_name_prefix"
                },
                {
                  "name": "support.tag.prelude.haskell",
                  "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(EQ|GT|Just|LT|Left|Nothing|Right|True|False)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))"
                }
              ]
            }
          }
        }
      ]
    },
    "where": {
      "patterns": [
        {
          "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))where(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))",
          "name": "keyword.other.haskell"
        }
      ]
    },
    "family_and_instance": {
      "patterns": [
        {
          "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(family|instance)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))",
          "name": "keyword.other.haskell"
        }
      ]
    },
    "invalid": {
      "patterns": [
        {
          "match": "\\S+",
          "name": "invalid.illegal.character-not-allowed-here.haskell"
        }
      ]
    },
    "function_name": {
      "patterns": [
        {
          "name": "entity.name.function.haskell",
          "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))"
        }
      ]
    },
    "assignment_op": {
      "patterns": [
        {
          "match": "=",
          "captures": {
            "0": {
              "name": "keyword.operator.assignment.haskell"
            }
          }
        }
      ]
    },
    "attribute_name": {
      "patterns": [
        {
          "name": "entity.other.attribute-name.haskell",
          "match": "(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}']))(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']))"
        }
      ]
    },
    "liquidhaskell_annotation": {
      "patterns": [
        {
          "name": "block.liquidhaskell.haskell",
          "contentName": "block.liquidhaskell.annotation.haskell",
          "begin": "\\{-@(?!#)",
          "end": "@-\\}",
          "patterns": [
            {
              "include": "#haskell_expr"
            }
          ]
        }
      ]
    },
    "shebang": {
      "patterns": [
        {
          "name": "comment.line.shebang.haskell",
          "match": "^\\#\\!.*\\brunhaskell\\b.*$"
        }
      ]
    },
    "haskell_expr": {
      "patterns": [
        {
          "include": "#infix_function"
        },
        {
          "include": "#unit"
        },
        {
          "include": "#empty_list"
        },
        {
          "include": "#quasi_quotes"
        },
        {
          "include": "#keywords"
        },
        {
          "include": "#pragma"
        },
        {
          "include": "#string"
        },
        {
          "include": "#newline_escape"
        },
        {
          "include": "#quoted_character"
        },
        {
          "include": "#comments"
        },
        {
          "include": "#infix_op"
        },
        {
          "include": "#comma"
        },
        {
          "include": "#lit_num"
        },
        {
          "include": "#scoped_type"
        },
        {
          "include": "#operator"
        },
        {
          "include": "#identifier"
        },
        {
          "include": "#type_ctor"
        }
      ]
    },
    "haskell_toplevel": {
      "patterns": [
        {
          "include": "#liquidhaskell_annotation"
        },
        {
          "include": "#class_decl"
        },
        {
          "include": "#instance_decl"
        },
        {
          "include": "#deriving_instance_decl"
        },
        {
          "include": "#foreign_import"
        },
        {
          "include": "#regular_import"
        },
        {
          "include": "#data_decl"
        },
        {
          "include": "#type_alias"
        },
        {
          "include": "#c_preprocessor"
        },
        {
          "include": "#scoped_type_override"
        },
        {
          "include": "#function_type_declaration"
        },
        {
          "include": "#haskell_expr"
        }
      ]
    },
    "haskell_source": {
      "patterns": [
        {
          "include": "#shebang"
        },
        {
          "include": "#module_decl"
        },
        {
          "include": "#haskell_toplevel"
        }
      ]
    }
  }
}